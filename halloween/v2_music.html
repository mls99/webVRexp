<!DOCTYPE html>
<!--


autumn tree 2
https://sketchfab.com/models/3d7ba66433f64c8585c7fd3ed688c7f2

dead bush
https://sketchfab.com/models/5fcc300e817d440f826b0cb24e3c652c

dead tree
https://sketchfab.com/models/ccc4088f050a4f708f3855c71d2bd9c4


 Suoni Di Genova » ghost_yacht.wav
https://freesound.org/people/suonidigenova/sounds/55055/

 Baïkal » baik6.wav

https://freesound.org/people/ashassin/sounds/8516/


https://freesound.org/people/HF2010/sounds/110497/

-->
<html lang="en">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-122855516-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());0
        gtag('config', 'UA-122855516-1');
    </script>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="./node_modules/three/build/three.min.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <!-- needed for loading Truetype Fonts -->
    <script src="./node_modules/three/examples/js/loaders/TTFLoader.js"></script>
    <script src="./node_modules/three/examples/js/libs/opentype.min.js"></script>

    <!-- needed to enter VR -->

    <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/de-puntillas-b-to-tiptoe-regular" type="text/css"/>

    <style type="text/css">
        /*
        orange: FF6515
        blue: 006C8D
        purple: 920084
        green: CAE807
        black: 000000
         */
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
            font-family: 'dpuntillasBtotiptoeRegular';
        }
        h1,h2,h3 {
            font-family: 'dpuntillasBtotiptoeRegular';
            font-weight: normal;
            font-style: normal;
            color: #ff6f15;
            /*background-color: #000000;*/
        }
        h1 {
            font-size: 15vmin;
            margin:0.25em;
        }
        h2 {
            margin:0.5em 0.25em;
            font-size: 6vmin;
            color: #920084;
            background-color: #CAE807;
        }
        h3 {
            margin:0;
            font-size: 4vmin;
            color: black;
            background-color: #FF6515;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: black;
            text-align: center;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
            /*display: inline-block;*/
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }

        #controls {
            margin: 0.25em;
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        #controls button {
            font-family: 'dpuntillasBtotiptoeRegular';
            font-weight: normal;
            font-style: normal;
            color: #ff6f15;
            font-size: 4vw;
            padding: 8px;
            background-color: #920084;
            border: 4px solid black;
        }
        #controls #click-to-play {
            background-color: white;
        }

        #how-text {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: black;
            text-align: center;
            display: none;
        }

        #credits-text {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: black;
            text-align: center;
            display: none;
        }

        #loading-indicator {
            display: block;
        }
        #loading-indicator * {
            color: white;
        }
        #controls {
            display: none;
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Monster Zoo</h1>
    <h2>The monsters have escaped. Target and hold them
        with your spectral vacuum!</h2>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <div id="controls">
        <button id="how">How to Play</button>
        <button id="click-to-play">Play Now</button>
        <button id="credits">Credits</button>
    </div>
</div>

<div id="how-text">
    <h1>How to Play</h1>
    <h2>1) aim your spectral vacuum at a monster</h2>
    <h2>2) hold until it is captured</h2>
    <h2>3) capture enough before time runs out </h2>
    <div class="controls">
        <button id="how-back">Back</button>
    </div>
</div>

<div id="credits-text">
    <h1>Credits</h1>
    <h2>concept and code by <a href="https://vr.josh.earth/">Josh Marinacci</a></h2>
    <h3>3D models from <a href="https://sketchfab.com/models/3d7ba66433f64c8585c7fd3ed688c7f2">Inuciian</a> and <a href="https://www.patreon.com/quaternius/posts">Quaternius</a></h3>
    <h3>music from <a href="http://freemusicarchive.org/music/Loyalty_Freak_Music/WITCHY_BATTY_SPOOKY_HALLOWEEN_IN_SEPTEMBER_">Loyalty Freak Music</a></h3>
    <h3>sounds from <a href="https://freesound.org/people/suonidigenova/sounds/55055/">Suoni Di Genova</a> and <a href="https://freesound.org/people/HF2010/sounds/110497/">HF2010</a> </h3>
    <div class="controls">
        <button id="credits-back">Back</button>
    </div>
</div>

<script type="module">
    import {POINTER_CLICK,
        POINTER_PRESS,
        POINTER_RELEASE,
        POINTER_ENTER, POINTER_EXIT, Pointer} from '../boilerplate/pointer.js'
    import VRStats from "../boilerplate/vrstats.js"
    import {t2} from "./T2.js"
    import GPUParticleSystem from "../particles/GPUParticleSystem2.js"
    import VRManager, {VR_DETECTED, VR_PRESENTCHANGE} from "../boilerplate/vrmanager.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = deg => deg * Math.PI/180
    const rand = (min,max) => Math.random()*(max-min) + min

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats, vrmanager;
    let worlds = []

    let timeLabel, monstersLabel, roundLabel

    const DEBUG = {
        FOG:true,
        STATS:true,
        MUSIC:true,
        TTF_FONT: false,
        TERRAIN:true,
        PARTICLES:false,
        GROUND:true,
        CAR:true,
        NUMBER_UPDATES:true,
        MONSTER: {
            CLIPS:true
        },
        ANIMS:true
    }

    const CONSTS = {
        COLORS: {
            orange: '#FF6515',
            blue: '#006C8D',
            purple: '#920084',
            green: '#CAE807',
            black: '#000000',
        },
        TERRAIN_SIZE: 10,
        SPEED_SCALE:50,
    }
    const SCORE = {
        TIME_LEFT: 0,
        CAPTURED: 0
    }
    const MONSTERS = {
        SLIME:'SLIME',
        SKELETON:'SKELETON',
        BAT:'BAT'
    }
    const LEVELS = [
        {
            SPEED: 0.02,
            TIME: 30,
            CAPTURE:2,
            CAPTURE_TIME:1,
            MONSTER_FREQUENCY:4,
            MONSTER:MONSTERS.SLIME
        },
        {
            SPEED: 0.04,
            TIME: 30,
            CAPTURE:3,
            CAPTURE_TIME:1.5,
            MONSTER_FREQUENCY:6,
            MONSTER: MONSTERS.SKELETON,
        },
        {
            SPEED: 0.06,
            TIME: 30,
            CAPTURE:4,
            CAPTURE_TIME:2,
            MONSTER_FREQUENCY:8,
            MONSTER: MONSTERS.BAT
        }
    ]
    let currentLevel = 0

    let intro_music, level_music, win_music, lose_music

    let captureEffect

    class SimpleText extends THREE.Object3D {
        constructor(w,h) {
            super()
            this.htmlCanvas = document.createElement('canvas')
            this.htmlCanvas.width = 128*w
            this.htmlCanvas.height = 128*h
            this.canvas_texture = new THREE.CanvasTexture(this.htmlCanvas)
            this.mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(w,h),
                new THREE.MeshLambertMaterial({map:this.canvas_texture})
            )
            this.add(this.mesh)
            this.font = '36px sans-serif'
            this.color = 'black';
            this.backgroundColor = 'gray'
        }
        setText(str) {
            if(!DEBUG.NUMBER_UPDATES) return
            const ctx = this.htmlCanvas.getContext('2d')
            ctx.fillStyle = this.backgroundColor
            ctx.fillRect(0,0,this.htmlCanvas.width, this.htmlCanvas.height)
            ctx.font = this.font
            ctx.fillStyle = this.color
            const lines = str.split("\n")
            const top = (36*lines.length)/2+this.htmlCanvas.height/2 - lines.length*36/2
            lines.forEach((line,i) => {
                const metrics = ctx.measureText(line)
                ctx.fillText(line,
                    this.htmlCanvas.width/2-metrics.width/2,
                    top+i*36
                )
                this.canvas_texture.needsUpdate = true
            })
        }
    }

    class TTFText extends THREE.Object3D {
        constructor(url) {
            super()

            const loader = new THREE.TTFLoader()
            const fontLoader = new THREE.FontLoader()
            loader.load(url,data => {
                this.numberFont = fontLoader.parse(data)
                this.rebuildGeometry()
            })
            this.text = 'A'
        }
        rebuildGeometry() {
            if(!this.numberFont) return
            const geo = new THREE.TextGeometry(this.text,{
                font: this.numberFont,
                size: 0.5,
                height: 0.1,
            })

            this.mesh = new THREE.Group()

            const outlineMaterial = new THREE.MeshLambertMaterial({
                color:0xff0000,
                side: THREE.BackSide,
                emissive: new THREE.Color(0xff0000),
                emissiveIntensity:0.5})
            outlineMaterial.onBeforeCompile = (shader) => {
                const token = '#include <begin_vertex>'
                const customTransform = `
                vec3 transformed = position + objectNormal*0.03;
            `
                shader.vertexShader = shader.vertexShader.replace(token,customTransform)
            }

            const mesh2 = new THREE.Mesh(geo,outlineMaterial)
            // const s = 1.1
            // mesh2.scale.set(s,s,s)
            this.mesh.add(mesh2)

            const mesh  = new THREE.Mesh(geo,new THREE.MeshLambertMaterial({color:0xffffff,
                side: THREE.FrontSide,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 1.0
            }))
            this.mesh.add(mesh)

            this.add(this.mesh)
        }
        setText(str) {
            this.text = str
            this.remove(this.mesh)
            this.rebuildGeometry()
        }
    }

    const IDENTITY_VECTOR = new THREE.Vector3(0,0,0)
    const IDENTITY_EULER = new THREE.Euler(0,0,0,'XYZ')
    function dumpTree(obj, indent) {
        if(!obj) return console.error("error")
        if(!indent) indent = ""
        let type = 'unknown'
        let name = 'unknown'
        if(obj.animations) {
            type = 'gltf'
            name = 'gltf'
        }

        if(obj.name) name = obj.name
        if(obj.type) type = obj.type
        console.log(indent,type,name)
        if(obj.position) {
            if(!obj.position.equals(IDENTITY_VECTOR)) {
                console.log(indent,"+ position",obj.position.toArray())
            }
        }
        if(obj.rotation) {
            // console.log(obj.rotation.distanceTo(IDENTITY_VECTOR))
            if(!obj.rotation.equals(IDENTITY_EULER)) {
                console.log(indent, "+ rotation",obj.rotation.toArray())
            }
        }
        if(obj.geometry) console.log(indent, '+ has geo')
        if(obj.material) console.log(indent, '+ has mat')
        if(obj.children) obj.children.forEach(ch => dumpTree(ch,indent+'  '))
        if(obj && obj.scene) obj.scene.children.forEach(ch => dumpTree(ch,indent+'  '))
    }

    let treemodels = null
    function setupTerrain() {
        let treeCount = 0

        const model_urls = [
            "./models/dead_bush/scene.gltf",
            "./models/dead_tree/scene.gltf",
            "./models/autumn_tree_2/scene.gltf",
        ]
        const ADJUSTMENTS = [
            {
                off: new THREE.Vector3(7, -0.2, 0),
                scale:1.0,
            },
            {
                off: new THREE.Vector3(2, 1, 15),
                scale:1.0,
            },
            {
                off: new THREE.Vector3(1, -7.2, 0),
                scale:0.5,
            },

        ]
        Promise.all(model_urls.map(url => loadGLTF(url))).then(models =>{
            console.log("got the models")
            console.log("tree fully loaded")
            treemodels = models

            // const mod = treemodels[0]
            // dumpTree(mod)

            worlds.push(makeWorld(0))
            worlds.push(makeWorld(CONSTS.TERRAIN_SIZE*-2))
            worlds.push(makeWorld(CONSTS.TERRAIN_SIZE*-4))
            worlds.forEach(w => scene.add(w))


            function makeTreeInstance(mod,adj) {
                const obj = mod.scene.children[0].clone()
                obj.scale.set(adj.scale,adj.scale,adj.scale)
                obj.position.set(0,0,0)
                obj.position.add(adj.off)
                return obj
            }


            function makeWorld(dz) {
                const world = new THREE.Group()
                world.position.z = dz

                //scroll at constant speed over a flat plane with N seconds to capture M monsters.
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(CONSTS.TERRAIN_SIZE*4, CONSTS.TERRAIN_SIZE*2),
                    new THREE.MeshLambertMaterial({color: CONSTS.COLORS.green})
                );
                // ground.material.color.setHSL(rand(0,1),1,0.5)
                ground.rotation.x = toRad(-90)
                if(DEBUG.GROUND) world.add(ground)



                for(let i=-14; i<15; i+=4) {
                    for(let j=6; j>-13; j-=4) {
                        const off = new THREE.Vector3(i+rand(-1,1),0,j+rand(-1,1))
                        // const off = new THREE.Vector3(i,0,j)
                        if(off.x > -3 && off.x < 3) {
                            continue
                        }
                        if(DEBUG.TERRAIN) {
                            let r = Math.floor(Math.random()*3)
                            // r = 2
                            const tree = makeTreeInstance(treemodels[r],ADJUSTMENTS[r])
                            tree.position.add(off)
                            treeCount++
                            stats.setProperty('trees',treeCount)
                            world.add(tree)
                        }
                    }
                }


                return world
            }
            function makeRandomTree() {
                let r = Math.floor(Math.random()*3)
                r = 2
                if(r === 0) return loadGLTF().then(mod => {
                    const off = new THREE.Vector3(7, -0.4, 0)
                    const obj = mod.scene.children[0]
                    obj.position.set(0, 0, 0)
                    obj.position.add(off)
                    return obj
                })
                if(r === 1) return loadGLTF().then(mod => {
                    const off = new THREE.Vector3(2, 1, 15)
                    const obj = mod.scene.children[0]
                    obj.position.set(0,0,0)
                    obj.position.add(off)
                    return obj
                })
                if(r === 2) return loadGLTF("./models/autumn_tree_2/scene.gltf").then(mod => {
                    dumpTree(mod)
                    const off = new THREE.Vector3(1, -7.2, 0)
                    let obj = mod.scene.children[0]
                    obj = obj.children[0]
                    obj.scale.set(0.5,0.5,0.5)
                    obj.position.set(0,0,0)
                    obj.position.add(off)
                    return obj
                })
            }

        })
    }
    function setupBackground() {
        scene.background = 0x000000
        scene.fog = new THREE.Fog('black',10,20)
    }
    function setupOverlay() {
        //time left in round
        if(DEBUG.TTF_FONT) {
            timeLabel = new TTFText("./fonts/d-puntillas-B-to-tiptoe.ttf")
        } else {
            timeLabel = new SimpleText(1,1)
            timeLabel.font = '64px dpuntillasBtotiptoeRegular';
            timeLabel.backgroundColor = CONSTS.COLORS.purple
            timeLabel.color = CONSTS.COLORS.green
        }
        timeLabel.position.set(-2,4,-4)
        timeLabel.setText("0")
        timeLabel.rotation.y = toRad(30)
        timeLabel.rotation.x = toRad(30)
        scene.add(timeLabel)

        if(DEBUG.ANIMS) t2.prop({
            target:timeLabel.rotation,
            property:'z',
            from:toRad(-10),
            to:toRad(10),
            duration:3,
            autoReverse:true,
            loop:-1
        }).start()

        //monsters left to catch
        if(DEBUG.TTF_FONT) {
            monstersLabel = new TTFText("./fonts/d-puntillas-B-to-tiptoe.ttf")
        } else {
            monstersLabel = new SimpleText(1,1)
            monstersLabel.font = '64px dpuntillasBtotiptoeRegular';
            monstersLabel.backgroundColor = CONSTS.COLORS.purple
            monstersLabel.color = CONSTS.COLORS.green
        }
        monstersLabel.position.set(2,4,-4)
        monstersLabel.setText("0")
        monstersLabel.rotation.y = toRad(-30)
        monstersLabel.rotation.x = toRad(30)
        scene.add(monstersLabel)

        if(DEBUG.ANIMS) t2.prop({
            target:monstersLabel.rotation,
            property:'z',
            from:toRad(10),
            to:toRad(-10),
            duration:4,
            autoReverse:true,
            loop:-1
        }).start()

        roundLabel = new SimpleText(7,1)
        roundLabel.backgroundColor = CONSTS.COLORS.black
        roundLabel.color = CONSTS.COLORS.orange

        roundLabel.position.set(0,2,-5)
        roundLabel.setText("Start Monster Zoo")
        roundLabel.font = '48px dpuntillasBtotiptoeRegular';
        scene.add(roundLabel)
    }

    function getCurrentLevel() {
        return LEVELS[currentLevel]
    }

    function setupStart() {
        SCORE.CAPTURED = 0
        SCORE.TIME_LEFT = 99
        SCORE.START_TIME = Date.now()
    }
    let captureTexture
    function setupVacuum() {

        //Must focus on monster for 1 full second in a cone of influence to fully capture it.
        //         Reverse particles and is sucked into your vacuum.
        //             Get a point.
        const hose = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1,0.05,1.5),
            new THREE.MeshLambertMaterial({color:0x888888})
        )
        hose.position.y = -0.25
        const nozzle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1,0.14,0.1),
            new THREE.MeshLambertMaterial({color:CONSTS.COLORS.orange})
        )
        nozzle.position.y = 0.5
        const group = new THREE.Group()
        group.add(hose)
        group.add(nozzle)
        group.rotation.x = -90 * Math.PI/180
        group.position.z = -1.0


        const textureLoader = new THREE.TextureLoader()
        captureTexture = textureLoader.load("./capture.png")
        captureTexture.wrapS = THREE.RepeatWrapping;
        captureTexture.wrapT = THREE.RepeatWrapping;
        captureTexture.repeat.set(4,0.2)
        captureEffect = new THREE.Mesh(
            new THREE.CylinderGeometry(1.0,0.13,5.0),
            new THREE.MeshLambertMaterial({
                color:'purple',
                map:captureTexture,
                transparent:true,
                opacity: 0.2,
                side: THREE.DoubleSide,
            })
        )
        captureEffect.position.y = 1.5+0.5+1
        captureEffect.visible = false
        group.add(captureEffect)

        pointer.controller1.add(group)

    }
    function setupCar() {
        const carBody = new THREE.Mesh(
            new THREE.CylinderGeometry(1,1,2),
            new THREE.MeshLambertMaterial({color:CONSTS.COLORS.purple})
        )
        carBody.rotation.x = toRad(90)
        carBody.position.set(0,0,0)
        scene.add(carBody)
    }

    let monsters
    let slime_model, skeleton_model, bat_model
    function setupMonsters() {
        monsters = new THREE.Group()
        scene.add(monsters)

        loadGLTF("./Slime.glb").then(model => {
            slime_model = model
            // dumpTree(slime_model)
        })
        loadGLTF("./Skeleton.glb").then(model => {
            skeleton_model = model
            // dumpTree(skeleton_model)
        })
        loadGLTF("./Bat.glb").then(model => {
            bat_model = model
            // dumpTree(bat_model)
        })
    }

    function setupMusic() {
        if(!DEBUG.MUSIC) return
        const audioListener = new THREE.AudioListener()
        camera.add(audioListener)

        const audioLoader = new THREE.AudioLoader()

        intro_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_01_-_Monster_Parade.mp3',(buffer) => {
            intro_music.setBuffer(buffer)
            intro_music.setVolume(0.75)
        })
        level_music = new THREE.Audio(audioListener)
        audioLoader.load("./music/Loyalty_Freak_Music_-_13_-_Ghost_Surf_Rock.mp3",(buffer) => {
            level_music.setBuffer(buffer)
            level_music.setVolume(0.75)
        })
        win_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_12_-_Halloween_Ghost_Party.mp3',(buffer) => {
            win_music.setBuffer(buffer)
            win_music.setVolume(0.75)
        })
        lose_music = new THREE.Audio(audioListener)
        audioLoader.load('./music/Loyalty_Freak_Music_-_05_-_We_all_gonna_die_.mp3',(buffer) => {
            lose_music.setBuffer(buffer)
            lose_music.setVolume(0.75)
        })
    }

    let vacuum_sound, capture_sound
    function setupSoundEffects() {
        const audioListener = new THREE.AudioListener()
        camera.add(audioListener)

        const audioLoader = new THREE.AudioLoader()
        vacuum_sound = new THREE.Audio(audioListener)
        audioLoader.load('./sounds/55055__suonidigenova__ghost-yacht.wav', (buffer) => {
            vacuum_sound.setBuffer(buffer)
        })
        capture_sound = new THREE.Audio(audioListener)
        audioLoader.load('./sounds/110497__hf2010__voice-of-your-demise.mp3', (buffer) => {
            capture_sound.setBuffer(buffer)
        })

    }

    let last_music = null
    function playMusic(music) {
        if(!DEBUG.MUSIC) return
        if(last_music && last_music !== music) {
            if(last_music.isPlaying) last_music.stop()
        }
        last_music = music
        if(!last_music.isPlaying) last_music.play()
    }
    let detected = false
    let resumeGameOnAnyClick = false
    function setupHTML() {
        on($("#how"),'click',() =>  $("#how-text").style.display = 'block')
        on($("#how-back"),'click',() => $("#how-text").style.display = 'none')
        on($("#credits"),'click',() =>  $("#credits-text").style.display = 'block')
        on($("#credits-back"),'click',() => $("#credits-text").style.display = 'none')

        const play = $("#click-to-play")
        play.innerText = "Play Now"
        on(play,'click',playGame)
        on(vrmanager,VR_DETECTED,()=> detected = true)
        on(vrmanager,VR_PRESENTCHANGE,()=> resumeGameOnAnyClick = !vrmanager.device.isPresenting)
        on($("body"),'click',evt => {
            if(resumeGameOnAnyClick) {
                evt.preventDefault()
                evt.stopPropagation()
                restartGame()
            }
        })
    }

    function playGame() {
        $("#overlay").style.visibility = 'hidden'
        playMusic(level_music)
        if(detected) vrmanager.enterVR()
        restartGame()
    }

    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        scene.background = new THREE.Color( 0xcccccc );
        const light = new THREE.DirectionalLight( 0xffffff, 0.7 );
        light.position.set( 0, 1, 1 ).normalize();
        scene.add( light );
        scene.add(new THREE.AmbientLight(0xffffff,0.2))
        stats = new VRStats(renderer)
        if(DEBUG.STATS) {
            camera.add(stats)
            scene.add(camera)
        }


        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {
            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),
            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:false,
            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,
            enableLaser:true,
            laserLength: 20,

        })

        // $("#overlay").style.display = 'none'

        setupTerrain()
        if(DEBUG.FOG) setupBackground()
        setupOverlay()
        setupMonsters()
        setupVacuum()
        if(DEBUG.CAR) setupCar()
        setupStart()
        setupMusic()
        setupSoundEffects()
        setupHTML()
    }

    function moveTerrain(time,delta) {
        const level = getCurrentLevel()
        worlds.forEach(w => {
            w.position.z += delta*level.SPEED*CONSTS.SPEED_SCALE
            if(w.position.z > CONSTS.TERRAIN_SIZE*2) {
                w.position.z = -CONSTS.TERRAIN_SIZE*4
            }
        })
    }


    /* ============= MONSTERS =============== */

    let lastMonster = 0

    function makeScaleAnim(captureTarget, start,end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:captureTarget.scale,
                property:p,
                from:start,
                to:end,
                duration: 0.5
            }))
        })
        return anim
    }
    function makePositionToAnim(target, end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:target.position,
                property:p,
                from:target.position[p],
                to:end[p],
                duration: 0.5
            }))
        })
        return anim
    }


    const cloneGltf = (gltf) => {
        const clone = {
            animations: gltf.animations,
            scene: gltf.scene.clone(true)
        };

        const skinnedMeshes = {};

        gltf.scene.traverse(node => {
            if (node.isSkinnedMesh) {
                skinnedMeshes[node.name] = node;
            }
        });

        const cloneBones = {};
        const cloneSkinnedMeshes = {};

        clone.scene.traverse(node => {
            if (node.isBone) {
                cloneBones[node.name] = node;
            }

            if (node.isSkinnedMesh) {
                cloneSkinnedMeshes[node.name] = node;
            }
        });

        for (let name in skinnedMeshes) {
            const skinnedMesh = skinnedMeshes[name];
            const skeleton = skinnedMesh.skeleton;
            const cloneSkinnedMesh = cloneSkinnedMeshes[name];

            const orderedCloneBones = [];

            for (let i = 0; i < skeleton.bones.length; ++i) {
                const cloneBone = cloneBones[skeleton.bones[i].name];
                orderedCloneBones.push(cloneBone);
            }

            cloneSkinnedMesh.bind(
                new THREE.Skeleton(orderedCloneBones, skeleton.boneInverses),
                cloneSkinnedMesh.matrixWorld);
        }

        return clone;
    }

    class Monster extends THREE.Object3D {
        constructor(type) {
            super()


            this.showMonster = (e) => {
                this.hover.visible = true
            }

            this.grabMonster = (e) => {
                vacuum_sound.play()
                captureEffect.visible = true
                captureTarget = this
                capturing = true
                clock.start()
                this.hover.material.color.set(0xff0000)
            }

            this.releaseMonster = (e) => {
                if(vacuum_sound.isPlaying) vacuum_sound.stop()
                captureEffect.visible = false
                capturing = false
                this.hover.visible = false
            }

            if(type === MONSTERS.SLIME) {}
            if(type === MONSTERS.SKELETON) {}
            if(type === MONSTERS.BAT) {}

            //create a mesh for selection
            this.grabTarget = new THREE.Mesh(
                new THREE.SphereGeometry(0.7),
                new THREE.MeshLambertMaterial({color:'green', wireframe:false})
            )
            this.grabTarget.material.visible = false
            this.grabTarget.position.y = 0.5
            this.grabTarget.userData.clickable = true
            this.add(this.grabTarget)
            on(this.grabTarget, POINTER_ENTER,   this.showMonster)
            on(this.grabTarget, POINTER_EXIT,    this.releaseMonster)
            on(this.grabTarget, POINTER_PRESS,   this.grabMonster)
            on(this.grabTarget, POINTER_RELEASE, this.releaseMonster)


            //hover effect
            this.hover = new THREE.Mesh(
                new THREE.SphereGeometry(0.7),
                new THREE.MeshLambertMaterial({color:'blue',transparent:true, opacity:0.5})
            )
            this.hover.position.y = 0.5
            this.hover.visible = false
            this.add(this.hover)


            //load the actual monster model
            if(type === MONSTERS.SLIME) this.makeSlime(slime_model)
            if(type === MONSTERS.SKELETON)  this.makeSkeleton(skeleton_model)
            if(type === MONSTERS.BAT) this.makeBat(bat_model)
        }
        makeSlime(master) {
            this.grabTarget.position.y = 0.4
            this.hover.position.y = 0.4
            master = cloneGltf(master)
            const monster = master.scene
            monster.rotation.y = toRad(-90)
            const s = 0.4
            monster.scale.set(s,s,s)
            monster.userData.clickable = false
            this.add(monster)
            if(DEBUG.MONSTER.CLIPS) {
                this.userData.animation = t2.parallel()
                    .and(t2.clip({
                        target: master,
                        name: 'Slime_Idle',
                        speed: 2,
                        loop: -1,
                        autoReverse: true
                    }))
                    .and(t2.prop({
                        target: monster.rotation,
                        property: 'y',
                        from: toRad(30 - 90),
                        to: toRad(-30 - 90),
                        loop: -1,
                        duration: 1.5,
                        autoReverse: true
                    }))
                    .start()
            }
        }
        makeSkeleton(master) {
            this.grabTarget.position.y = 0.75
            this.hover.position.y = 0.75
            master = cloneGltf(master)
            const monster = master.scene
            const s = 0.3
            monster.scale.set(s,s,s)
            monster.userData.clickable = false
            this.add(monster)
            if(DEBUG.MONSTER.CLIPS) {
                this.userData.animation = t2.parallel()
                    .and(t2.clip({
                        target: master,
                        name: 'Skeleton_Attack',
                        speed: 1,
                        loop: -1,
                        autoReverse: true
                    }))
                    .start()
            }
        }
        makeBat(master) {
            this.grabTarget.position.y = 0.75
            this.hover.position.y = 0.75
            master = cloneGltf(master)
            const monster = master.scene
            const s = 0.3
            monster.scale.set(s,s,s)
            monster.userData.clickable = false
            this.add(monster)
            if(DEBUG.MONSTER.CLIPS) {
                this.userData.animation = t2.parallel()
                    .and(t2.clip({
                        target: master,
                        name: 'Bat_Flying',
                        speed: 1,
                        loop: -1,
                        // autoReverse:true
                    }))
                    .start()
            }
        }
    }

    let capturing = false
    let captureTarget = null
    const clock = new THREE.Clock(true)

    /*
    let particles
    function makeParticles(target) {
        const texture_loader = new THREE.TextureLoader()
        scorch_texture = texture_loader.load('../particles/kenney_particlePack/PNG/scorch_01.png')

        const options = {
            position: new THREE.Vector3(0,0,0),
            positionRandomness: 0.0,
            velocity: new THREE.Vector3(0.0, -0.5, 0.0),
            velocityRandomness: 1.0,
            acceleration: new THREE.Vector3(0.0,0.0,0.0),

            color: new THREE.Color(1.0,0.0,1.0),
            endColor: new THREE.Color(0.0,1.0,1.0),
            colorRandomness: 0.0,

            lifetime: 0.5,
            fadeIn:0.001,
            fadeOut:0.001,
            size: 60,
            sizeRandomness: 0.0,
        }

        particles = new GPUParticleSystem({
            maxParticles: 10000,
            particleSpriteTex: scorch_texture,
            blending: THREE.AdditiveBlending,
            onTick:(system,time) => {
                for (let i = 0; i < 10; i++) {
                    options.velocity.set(rand(-2,2),rand(-2,2), 0)
                    system.spawnParticle(options);
                }
            }})
        particles.position.z = -5
        particles.position.copy(target.position)
        target.userData.particles = particles
        scene.add(particles)
    }
    */

    function updateCapture() {
        if(!capturing) return
        const level = getCurrentLevel()
        if(clock.getElapsedTime() > level.CAPTURE_TIME) {

            capturing = false
            SCORE.CAPTURED += 1
            monstersLabel.setText(`${SCORE.CAPTURED}`)
            const monster = captureTarget
            const pos = monster.position.clone()
            if(DEBUG.ANIMS) {
                t2.sequence()
                    .then(t2.prop({
                        target: monster.position,
                        property: 'y',
                        from: pos.y,
                        to: pos.y + 1.0,
                        duration: 0.3,
                    }))
                    .then(t2.prop({
                        target: monster.position,
                        property: 'x',
                        from: pos.x - 0.2,
                        to: pos.x + 0.2,
                        duration: 0.05,
                        autoReverse: true,
                        loop: 10
                    }))
                    .then(t2.parallel()
                        .and(makeScaleAnim(monster, monster.scale.x, 0.03))
                        .and(makePositionToAnim(monster, pointer.controller1.position.clone()))
                        .and(() => {
                            if (capture_sound.isPlaying) capture_sound.stop()
                            capture_sound.play()
                        })
                    )
                    .then(() => {
                        captureEffect.visible = false
                        monster.userData.shouldRemove = true
                    })
                    .start()
            } else {
                captureEffect.visible = false
                monster.userData.shouldRemove = true
            }
        }
    }
    function loadGLTF(url) {
        return new Promise((res,rej)=>{
            const loader = new THREE.GLTFLoader()
            loader.load(url,(m)=>{
                res(m)
            })
        })
    }

    function updateMonsters(time,delta) {
        if(!running) return
        const diff = (time - lastMonster)
        const level = getCurrentLevel()
        if(diff > level.MONSTER_FREQUENCY) {
            lastMonster = time
            const monster = new Monster(level.MONSTER)
            monster.position.set(rand(-3, 3), 0, -20)
            monsters.add(monster)
        }
        const remove = []
        monsters.children.forEach(m => {
            m.position.z += delta*level.SPEED*CONSTS.SPEED_SCALE
            if(m.position.z > 20) remove.push(m)
            if(m.userData.shouldRemove) {
                remove.push(m)
                if(m.userData.animation) m.userData.animation.kill()
            }
        })
        remove.forEach(m => m.parent.remove(m))
        stats.setProperty('monsters',monsters.children.length)
    }




    let running = false
    function restartGame() {
        currentLevel = 0
        startLevel()
    }
    function startLevel() {
        playMusic(level_music)
        running = true
        SCORE.START_TIME = Date.now()
        SCORE.CAPTURED = 0
        monstersLabel.setText(`${SCORE.CAPTURED}`)
        const level = getCurrentLevel()
        t2.sequence()
            .then(()=>{
                roundLabel.visible = true
                roundLabel.setText(`capture ${level.CAPTURE} in ${level.TIME} s`)
                monstersLabel.setText('0')
            })
            .wait(1)
            .then((()=> roundLabel.visible = false))
            .start()
    }

    function showNextlevelScreen() {
        running = false
        roundLabel.setText("level complete")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            currentLevel++
            startLevel()
        }
        pointer.on(POINTER_CLICK,handler)
    }
    function showLoseScreen() {
        running = false
        playMusic(lose_music)
        roundLabel.setText("game over. click to play again")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            restartGame()
        }
        pointer.on(POINTER_CLICK,handler)
    }

    function showWinScreen() {
        running = false
        playMusic(win_music)
        roundLabel.setText("you win. click to play again")
        roundLabel.visible = true
        const handler = () => {
            pointer.off(POINTER_CLICK,handler)
            roundLabel.visible = false
            restartGame()
        }
        pointer.on(POINTER_CLICK,handler)
    }
    function updateTime(time) {
        if(!running) return
        const level = getCurrentLevel()
        const left = (level.TIME-Math.floor((Date.now()-SCORE.START_TIME)/1000))
        if(left !== SCORE.TIME_LEFT) {
            SCORE.TIME_LEFT = left
            timeLabel.setText(`${SCORE.TIME_LEFT}`)
        }

        if(left <= 0) {
            running = false
            const level = getCurrentLevel()
            if(SCORE.CAPTURED >= level.CAPTURE) {
                // WIN
                if (currentLevel + 1 === LEVELS.length) {
                    showWinScreen()
                } else {
                    // NEXT ROUND
                    showNextlevelScreen()
                }
            } else {
                showLoseScreen()
            }
        }
    }

    const diff = new THREE.Clock()
    function render(time) {
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        if(captureTexture && captureEffect && captureEffect.visible) {
            captureTexture.offset.set(0,time/1000)
        }
        // if(particles && captureTarget) {
        //     const group = captureTarget.parent
        //     particles.position.copy(group.position)
        //     particles.update(time)
        // }
        const delta = diff.getDelta()
        moveTerrain(time/1000,delta)
        updateMonsters(time/1000,delta)
        updateCapture(time/1000)
        updateTime(time)
        t2.update()
        renderer.render( scene, camera );
    }

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 20 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        vrmanager = new VRManager(renderer)

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            // console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#controls').style.display = 'block'
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            // console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }
    initScene()
    renderer.setAnimationLoop(render)
</script>
</body>
</html>
