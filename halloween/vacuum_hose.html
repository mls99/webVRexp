<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="./node_modules/three/build/three.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <!--<script src="../boilerplate/vrstats.js" type="module"></script>-->

    <style type="text/css">
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    /*

    monster mover

    pick a random spot in a circle around you (pick a random angle and convert to cartesian coords)
    pick a random heading
    pick a target heading
    on each tick
        rotate skeleton by 10 degree to better match the heading
        move skeleton in direction of heading by 0.01 meters
    every N ticks
        pick a new random target heading

    if skeleton exceeds bounds of play area it stops, rotates 90 degrees clockwise, then tries again


    move the camera out to see him moving around
    add plane to show where he is




     */
    import {POINTER_CLICK, POINTER_ENTER, POINTER_EXIT, POINTER_PRESS, POINTER_RELEASE, Pointer} from '../boilerplate/pointer.js'
    import GPUParticleSystem from '../particles/GPUParticleSystem.js'
    import VRStats from "../boilerplate/vrstats.js"



    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    let skel_model, particles, unit
    let sucking = false
    let suck_tween, move_tween

    const PLAY_BOUNDS = {
        WIDTH: 10,
        HEIGHT: 10,
    }
    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        //set the background color of the scene
        scene.background = new THREE.Color( 0x444444 );

        //a standard light
        const light = new THREE.DirectionalLight( 0xffffff, 1.0 );
        light.position.set( 1, 1, 1 ).normalize();
        scene.add( light );


        scene.add(new THREE.AmbientLight())



        // enable stats visible inside VR
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),
            // mouseSimulatesController:true,

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:false,
        })


        //load a monster
        unit = new THREE.Group()
        const loader = new THREE.GLTFLoader()
        loader.load("./Skeleton.glb",(m)=> {
            m.scene.position.y = -0.3
            m.scene.position.z = 0
            m.scene.scale.set(0.5,0.5,0.5)
            m.scene.userData.clickable = true
            skel_model = m
            unit.add(skel_model.scene)
            // $('#overlay').style.display = 'none'
        })
        unit.position.set(0,0,-5)

        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(1.30,32,32),
            new THREE.MeshLambertMaterial({
                color:0x00ff00,
                transparent:true,
                opacity:0.0,
            })
        )
        glow.userData.clickable = true
        glow.visible = true
        glow.position.set(0,1,0)
        unit.add(glow)

        scene.add(unit)

        //add hose to the controller

        const hose = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1,0.05,1.0),
            new THREE.MeshLambertMaterial({color:0x888888})
        )
        hose.rotation.x = -90 * Math.PI/180
        hose.position.z = -1.0
        pointer.controller1.add(hose)


        const textureLoader = new THREE.TextureLoader()
        const options = {
            maxParticles: 10000,
            position: new THREE.Vector3(0, 0, -2),
            // positionRandomness: 0.4,
            baseVelocity: new THREE.Vector3(0.0, 0.0, -2),
            velocity: new THREE.Vector3(2.0, 2.0, 0),
            velocityRandomness: 2.0,
            acceleration: new THREE.Vector3(0, 0.0, 0),
            baseColor: new THREE.Color(1.0, 0.0, 0.5),
            color: new THREE.Color(0.1, 0.5, 0.2),
            colorRandomness: 0.5,
            lifetime: 2,
            size: 40,
            fadeIn: 0.001,
            fadeOut: 0.001,
            reverseTime:true,
            sizeRandomness: 0.0,
            particleSpriteTex: textureLoader.load('../particles/tex/particle2.png'),
            blending: THREE.AdditiveBlending,
            onTick:(system,time) => {
                if(!sucking) return
                options.velocity.x = options.baseVelocity.x + system.random() * options.velocityRandomness
                options.velocity.y = options.baseVelocity.y + system.random() * options.velocityRandomness
                options.velocity.z = options.baseVelocity.z //+ //system.random() * options.velocityRandomness
                system.spawnParticle( options );
            }
        }
        particles = new GPUParticleSystem(options)

        // TODO: putting the particles inside of the controller slows down from 60fps to 30fps. why?
        // pointer.controller1.add(particles)
        scene.add(particles)



        //when hover on monster make it glow
        on(glow,POINTER_ENTER,()=> glow.material.opacity = 0.5)
        //when hover off monster take away the glow
        on(glow,POINTER_EXIT,()=> glow.material.opacity = 0.0)
        //make particles suck into hose, use different particles shape to show how they streak in
        on(glow,POINTER_PRESS,()=>{
            sucking = true
            const shake_tween = new Tweenie({
                target:skel_model.scene,
                duration: 0.5,
                interpolation: (a,b,t) => Tweenie.Lerp(a,b,Math.sin(t*15*Math.PI*2)),
                props: { position: { from: skel_model.scene.position.clone(), to: new THREE.Vector3(0.05,0,0)}}
            })
            const scale_tween = new Tweenie({
                target:unit,
                duration: 1.0,
                props: {
                    scale:    { from: unit.scale.clone(),    to: new THREE.Vector3(0.2,0.2,0.2)},
                }
            })
            const wait_tween = new Tweenie({
                duration: 1.0
            })
            move_tween = new Tweenie({
                target:unit,
                duration:1.0,
                props: {
                    position: { from: unit.position.clone(), to: new THREE.Vector3(0,0,0)}
                }
            })
            wait_tween.onEnd(()=>{
                console.log("moving now")
                move_tween.start()
            })
            move_tween.onEnd(()=>{
                console.log("really captured now. yay!")
            })

            suck_tween = new ParallelTweenie([shake_tween, scale_tween, wait_tween])
            suck_tween.start()
            /*
            suck_tween = new Tweenie({
                target:unit,
                duration: 2.0,
                props: {
                    // position: { from: unit.position.clone(), to: new THREE.Vector3(0.1,0,-5)},
                    // position: { from: unit.position.clone(), to: unit.position.clone()},
                    scale:    { from: unit.scale.clone(),    to: new THREE.Vector3(0.2,0.2,0.2)},
                }
            }).onEnd(()=>{
                console.log("done")
                unit.visible = false
            })
            .start()
            */
        })
        on(glow,POINTER_RELEASE,()=>{
            sucking = false
            if(suck_tween)suck_tween.stop()
        })
        //when click on monster stop his moving, make him shake, shrink into hose, then fade away

        //make glow around monster animate all crazy






    }

    //called on every frame. customize this
    function render(time) {
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        //rotate the cube on every tick
        particles.update( time );
        if(suck_tween) suck_tween.update(time)
        if(move_tween) move_tween.update(time)

        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>

