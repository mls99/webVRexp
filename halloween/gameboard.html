<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
    <script>
        (function(f, a, t, h, o, m){
            a[h]=a[h]||function(){
                (a[h].q=a[h].q||[]).push(arguments)
            };
            o=f.createElement('script'),
                m=f.getElementsByTagName('script')[0];
            o.async=1; o.src=t; o.id='fathom-script';
            m.parentNode.insertBefore(o,m)
        })(document, window, '//stats.josh.earth/tracker.js', 'fathom');
        fathom('set', 'siteId', 'GISNV');
        fathom('trackPageview');
    </script>
    <!-- / Fathom -->
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="./node_modules/three/build/three.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <!--<script src="../boilerplate/vrstats.js" type="module"></script>-->

    <style type="text/css">
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK, POINTER_ENTER, POINTER_EXIT, POINTER_MOVE,
    POINTER_RELEASE,
        POINTER_PRESS, Pointer} from '../boilerplate/pointer.js'
    import {
        Color, Mesh, SphereBufferGeometry, Group, BoxBufferGeometry,
        MeshLambertMaterial, MeshBasicMaterial, MeshStandardMaterial,
        Scene, PerspectiveCamera, WebGLRenderer,
        DefaultLoadingManager, TextureLoader,
        DirectionalLight, AmbientLight, PointLight,
        Quaternion, Vector3, Spherical,
        MeshPhongMaterial,
        CylinderBufferGeometry
    } from "../boilerplate/node_modules/three/build/three.module.js"

    // import VRStats from "../boilerplate/vrstats.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    let skel_mixer, skel_model, skel_move_action, animation, skel_idle_action
    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        //set the background color of the scene
        scene.background = new Color( 0x333333 );

        //load a cat texture
        const texture_loader = new TextureLoader()

        //a standard light
        const light = new DirectionalLight( 0xffffff, 1.0 );
        light.position.set( -0.3, 1, 1 ).normalize();
        scene.add( light );
        scene.add( new AmbientLight(0xffffff,0.2))





        // enable stats visible inside VR
        // stats = new VRStats(renderer)
        // camera.add(stats)
        // scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:false,
        })






        /*
            create a grid of squares
            on each square put a monster
            click on a monster to select it
            the monster has a glow of some sort around it
            click on an empty square to select the target
            slide the monster moving to the target square
            grab the side of the board to rotate it around

         */


        const board = new Group()
        const glow = new Mesh(
            new BoxBufferGeometry(0.7,5,0.7),
            new MeshLambertMaterial({
                color:'0xffffff',
                opacity:0.3,
                transparent:true
            })
        )
        glow.visible = false
        board.add(glow)

        let selected = null

        function lerp (min,max,t) {
            return (max-min)*t + min
        }

        animation = {
            target:null,
            props:{},
            running:false,
            startTime:null,
            duration: 1000,
            move: function() {
                animation.running = true
            },
            animate: function (time) {
                if(!animation.running) return
                if(!animation.startTime) animation.startTime = time
                const t = (time-animation.startTime)/animation.duration
                const props = animation.props
                Object.keys(props).forEach(prop => {
                    const start = props[prop][0]
                    const end = props[prop][1]
                    if(start instanceof Vector3) {
                        animation.target[prop].set(
                            lerp(start.x,end.x,t),
                            lerp(start.y,end.y,t),
                            lerp(start.z,end.z,t)
                        )
                    }
                })
                if(t > 1) {
                    animation.running = false
                    animation.startTime = null
                    if(animation.onDone) animation.onDone()
                }
            }
        }
        function animateUnit(src,dst) {
            if(!selected) return
            animation.target = selected
            const len = selected.position.distanceTo(dst.position)
            console.log(len)
            animation.duration = len*500
            animation.props = {
                position:[selected.position.clone(), dst.position.clone()]
            }
            animation.onDone = () => {
                skel_move_action.stop()
            }
            animation.move()
            glow.visible = false
            selected = null

            // selected.position.x = dst.position.x
            // selected.position.z = dst.position.z
            skel_move_action.play()
        }

        const size = 7
        for(let i=0; i<size; i++) {
            for(let j=0; j<size; j++) {
                const tile = new Mesh(
                    new BoxBufferGeometry(0.9,0.2,0.9),
                    new MeshPhongMaterial({color:0xff0000})
                )
                tile.position.x = i - size/2 + 0.5
                tile.position.z = j - size/2 + 0.5
                tile.userData.clickable = true
                board.add(tile)
                on(tile,POINTER_ENTER, e => tile.material.color.set(0xff8888))
                on(tile,POINTER_EXIT,  e => tile.material.color.set(0xff0000))
                on(tile,'click',(e)=>{
                    animateUnit(selected,e.target)
                })

            }
        }

        const unit = new Group()
        const loader = new THREE.GLTFLoader()
        loader.load("./Skeleton.glb",(m)=> {
            console.log(m)
            m.scene.position.y = -0.3
            m.scene.position.z = 0
            m.scene.scale.set(0.5,0.5,0.5)
            m.scene.userData.clickable = true
            skel_model = m
            unit.add(skel_model.scene)

            skel_mixer = new THREE.AnimationMixer(skel_model.scene)
            skel_idle_action = skel_mixer.clipAction(THREE.AnimationClip.findByName(skel_model.animations,'Skeleton_Idle'))
            skel_idle_action.setLoop(THREE.LoopPingPong)
            skel_idle_action.play()

            const clip = THREE.AnimationClip.findByName(skel_model.animations,'Skeleton_Death')
            const action = skel_mixer.clipAction(clip)
            action.time = clip.duration
            action.setLoop(THREE.LoopOnce,1)
                .setEffectiveTimeScale(-0.3)
                .play()

            const moveClip = THREE.AnimationClip.findByName(skel_model.animations,"Skeleton_Running")
            skel_move_action = skel_mixer.clipAction(moveClip)
        })

        const placeHolder = new Mesh(
            new BoxBufferGeometry(0.5,5,0.5),
            new MeshPhongMaterial({color:0x00ff00, opacity:0.0, transparent:true})
        )

        placeHolder.userData.clickable = true
        placeHolder.position.y = 0.25 + 0.1
        unit.add(placeHolder)
        unit.position.x = -size/2 + 0.5
        unit.position.z = -size/2 + 0.5
        // unit.position.y = 0.25+0.1
        unit.userData.clickable = true

        on(placeHolder,POINTER_ENTER, e => e.target.material.opacity = 0.5)
        on(placeHolder,POINTER_EXIT,  e => e.target.material.opacity = 0.0)
        on(placeHolder,'click',(e)=>{
            glow.position.copy(e.target.parent.position)
            glow.visible = true
            selected = unit
        })
        board.add(unit)

        board.position.z = -5 - size/2
        board.position.x = 0
        scene.add(board)


        const plate = new Mesh(
            new CylinderBufferGeometry(size/2+2,size/2+2.5,0.5,10),
            new MeshLambertMaterial({color:0x00ff00})
        )
        plate.userData.clickable = true
        plate.position.y = -0.5
        plate.position.z = -5 - size/2
        let rotating = false
        let startRotation = 0
        let startPoint = new Vector3(0,0,0)
        on(plate, POINTER_ENTER, (e) =>{
            plate.material.color.set(0x88ff88)
        })
        on(plate, POINTER_EXIT, (e) =>{
            plate.material.color.set(0x00ff00)
        })
        on(plate,POINTER_PRESS,(e) => {
            startRotation = plate.rotation.y
            rotating = true
            startPoint = e.point
        })
        on(plate,POINTER_MOVE, (e) => {
            if(!rotating) return
            plate.rotation.y = startRotation + (e.point.x - startPoint.x)/2
            board.rotation.y = plate.rotation.y
        })
        on(plate,POINTER_RELEASE,e => {
            rotating = false
        })

        scene.add(plate)


        if($("#enter-vr")) $("#enter-vr").removeAttribute('disabled')
        $("#overlay").style.visibility = 'hidden'


    }

    const clock = new THREE.Clock(true)
    //called on every frame. customize this
    function render(time) {
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        if(skel_mixer) skel_mixer.update(clock.getDelta())
        if(animation) animation.animate(time)
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new Scene();
        camera = new PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.vr.enabled = true;
        renderer.gammaOutput = true
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        // THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
        //     console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        // }
        // THREE.DefaultLoadingManager.onLoad = () => {
        //     console.log(`loading complete`)
        //     console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        // }
        // THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
        //     console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
        //     $("#progress").setAttribute('value',100*(loaded/total))
        // }
        // THREE.DefaultLoadingManager.onError = (url) => {
        //     console.log(`error loading ${url}`)
        // }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
