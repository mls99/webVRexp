<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="./node_modules/three/build/three.min.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <!-- needed for loading Truetype Fonts -->
    <script src="./node_modules/three/examples/js/loaders/TTFLoader.js"></script>
    <script src="./node_modules/three/examples/js/libs/opentype.min.js"></script>

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <style type="text/css">
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>


<div id="overlay">
    <h1>Monster Zoo</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    import {POINTER_CLICK,
        POINTER_PRESS,
        POINTER_RELEASE,
        POINTER_ENTER, POINTER_EXIT, Pointer} from '../boilerplate/pointer.js'
    import VRStats from "../boilerplate/vrstats.js"
    import {t2} from "./T2.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = deg => deg * Math.PI/180

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;
    let worlds = []

    let timeLabel, monstersLabel, roundLabel

    const CONSTS = {
        SCROLL_SPEED: 0.03,
        ROUND_TIME: 15,
        CAPTURE_TIME: 1,
    }
    const SCORE = {
        TIME_LEFT: 0,
        CAPTURED: 0
    }
    const LEVELS = [
        {
            CAPTURE:2,
        },
        {
            CAPTURE:3,
        },
        {
            CAPTURE:4,
        }
    ]
    let currentLevel = 0


    class SimpleText extends THREE.Object3D {
        constructor(w,h) {
            super()
            this.htmlCanvas = document.createElement('canvas')
            this.htmlCanvas.width = 128*w
            this.htmlCanvas.height = 128*h
            this.canvas_texture = new THREE.CanvasTexture(this.htmlCanvas)
            this.mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(w,h),
                new THREE.MeshLambertMaterial({map:this.canvas_texture})
            )
            this.add(this.mesh)
            // text.position.set(0,4,-4)
            // scene.add(text)
        }
        setText(str) {
            const ctx = this.htmlCanvas.getContext('2d')
            ctx.fillStyle = 'white'
            ctx.fillRect(0,0,this.htmlCanvas.width, this.htmlCanvas.height)
            ctx.font = '36px sans-serif'
            ctx.fillStyle = 'black'
            const metrics = ctx.measureText(str)
            ctx.fillText(str,
                this.htmlCanvas.width/2-metrics.width/2,
                (36/2+this.htmlCanvas.height/2))
            this.canvas_texture.needsUpdate = true
        }
    }

    function setupTerrain() {
        function makeWorld(dz) {
            const world = new THREE.Group()
            world.position.z = dz

            //scroll at constant speed over a flat plane with N seconds to capture M monsters.
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 11),
                new THREE.MeshLambertMaterial({color: 'orange'})
            );
            ground.rotation.x = toRad(-90)
            ground.position.z = -5
            world.add(ground)


            for (let i = 0; i < 10; i++) {
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 1, 0.3),
                    new THREE.MeshLambertMaterial({color: 'gray'})
                )
                const even = i % 2 === 0
                block.position.set(even ? 1 : -1, 0.5, -i)
                world.add(block)
            }
            return world
        }
        worlds.push(makeWorld(0))
        worlds.push(makeWorld(-10))
        worlds.push(makeWorld(-20))
        worlds.forEach(w => scene.add(w))
    }
    function setupBackground() {
        scene.background = 0x000000
        scene.fog = new THREE.Fog('black',10,25)

        const loader = new THREE.TextureLoader()
        loader.load("./eso0932a-sky-3k.jpg",(tex) => {
            tex.offset.set(-0.1,-0.1)
            tex.wrapS = THREE.RepeatWrapping
            tex.wrapT = THREE.RepeatWrapping
            const sky = new THREE.Mesh(
                new THREE.SphereGeometry(20,32,32),
                new THREE.MeshBasicMaterial({
                    color:0xcccccc,
                    side: THREE.BackSide,
                    map: tex
                })
            )
            scene.add(sky)
        })
    }
    function setupOverlay() {
        //time left in round
        timeLabel = new SimpleText(1,1)
        timeLabel.position.set(-2,4,-5)
        timeLabel.setText("0")
        scene.add(timeLabel)

        //monsters left to catch
        monstersLabel = new SimpleText(1,1)
        monstersLabel.position.set(2,4,-5)
        monstersLabel.setText("0")
        scene.add(monstersLabel)


        roundLabel = new SimpleText(4,1)
        roundLabel.position.set(0,2,-5)
        roundLabel.setText("start round")
        scene.add(roundLabel)
    }

    function getCurrentLevel() {
        return LEVELS[currentLevel]
    }

    function setupStart() {
        //show click to start
        //start round
        // when round ends you win or lose depending on how many you got.

        SCORE.CAPTURED = 0
        SCORE.TIME_LEFT = CONSTS.ROUND_TIME
        SCORE.START_TIME = Date.now()
        restartGame()
    }
    function setupVacuum() {
        //Must focus on monster for 1 full second in a cone of influence to fully capture it.
        //         Reverse particles and is sucked into your vacuum.
        //             Get a point.

    }

    let monsters
    function setupMonsters() {
        monsters = new THREE.Group()
        scene.add(monsters)
    }

    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        scene.background = new THREE.Color( 0xcccccc );
        const light = new THREE.DirectionalLight( 0xffffff, 1.0 );
        light.position.set( 1, 1, 1 ).normalize();
        scene.add( light );
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)


        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {
            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),
            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:true,
            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,

        })

        $("#overlay").style.display = 'none'

        setupTerrain()
        setupBackground()
        setupOverlay()
        setupMonsters()
        setupVacuum()
        setupStart()
    }

    function moveTerrain(time) {
        worlds.forEach(w => {
            w.position.z += CONSTS.SCROLL_SPEED
            if(w.position.z > 10) {
                w.position.z = -20
            }
        })
    }

    let lastMonster = 0
    const rand = (min,max) => Math.random()*(max-min) + min


    function makeScaleAnim(captureTarget, start,end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:captureTarget.scale,
                property:p,
                from:start,
                to:end,
                duration: 0.5
            }))
        })
        return anim
    }
    function makePositionToAnim(target, end) {
        const anim = t2.parallel()
        const props = ['x','y','z']
        props.forEach(p => {
            anim.and(t2.prop({
                target:target.position,
                property:p,
                from:target.position[p],
                to:end[p],
                duration: 0.5
            }))
        })
        return anim
    }


    let capturing = false
    let captureTarget = null
    const clock = new THREE.Clock(true)
    function grabMonster(e) {
        e.target.material.color.set(0xffcccc)
        captureTarget = e.target
        capturing = true
        clock.start()
    }
    function releaseMonster(e) {
        capturing = false
        e.target.material.color.set(0x00ff00)
    }
    function updateCapture() {
        if(!capturing) return
        if(clock.getElapsedTime() > CONSTS.CAPTURE_TIME) {
            capturing = false
            SCORE.CAPTURED += 1
            monstersLabel.setText(`${SCORE.CAPTURED}`)
            const pos = captureTarget.position.clone()
            t2.sequence()
                .then(t2.prop({
                    target:captureTarget.position,
                    property:'x',
                    from:pos.x-0.5,
                    to:  pos.x+0.5,
                    duration: 0.05,
                    autoReverse:true,
                    loop:10
                }))
                .then(t2.parallel()
                    .and(makeScaleAnim(captureTarget,1.0,0.1))
                    .and(makePositionToAnim(captureTarget,new THREE.Vector3(0,1.5,0)))
                )
                .then(()=>{
                    captureTarget.userData.shouldRemove = true
                })
                .start()
        }
    }
    function updateMonsters(time) {
        const diff = (time - lastMonster)
        if(diff > 3) {
            lastMonster = time
            const monster = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 8),
                new THREE.MeshLambertMaterial({color: 'green'})
            )
            monster.position.set(rand(-3, 3), 1, -30)
            monster.userData.clickable = true
            monsters.add(monster)
            on(monster, POINTER_EXIT,  releaseMonster)
            on(monster, POINTER_PRESS, grabMonster)
            on(monster, POINTER_RELEASE, releaseMonster)
        }
        const remove = []
        monsters.children.forEach(m => {
            m.position.z += CONSTS.SCROLL_SPEED
            if(m.position.z > 20) remove.push(m)
            if(m.userData.shouldRemove) remove.push(m)
        })

        remove.forEach(m => m.parent.remove(m))
    }

    let running = false
    function restartGame() {
        currentLevel = 0
        startLevel()
    }
    function startLevel() {
        running = true
        SCORE.START_TIME = Date.now()
        SCORE.CAPTURED = 0
        monstersLabel.setText(`${SCORE.CAPTURED}`)
        const level = getCurrentLevel()
        t2.sequence()
            .then(()=>{
                roundLabel.setText(`capture ${level.CAPTURE} in ${CONSTS.ROUND_TIME} s`)
                monstersLabel.setText('0')
            })
            .wait(1)
            .then((()=> roundLabel.visible = false))
            .start()
    }
    function updateTime(time) {
        if(!running) return
        const left = (CONSTS.ROUND_TIME-Math.floor((Date.now()-SCORE.START_TIME)/1000))
        if(left !== SCORE.TIME_LEFT) {
            SCORE.TIME_LEFT = left
            timeLabel.setText(`${SCORE.TIME_LEFT}`)
        }

        if(left <= 0) {
            running = false
            const level = getCurrentLevel()
            if(SCORE.CAPTURED >= level.CAPTURE) {
                // WIN
                if (currentLevel + 1 === LEVELS.length) {
                    t2.sequence()
                        .then(()=>{
                            roundLabel.setText("you win")
                            roundLabel.visible = true
                        })
                        .wait(2)
                        .then(()=>restartGame())
                        .start()
                } else {
                    // NEXT ROUND
                    t2.sequence()
                        .then(()=>{
                            roundLabel.setText("level complete")
                            roundLabel.visible = true
                        })
                        .wait(2)
                        .then(()=>{
                            currentLevel++
                            startLevel()
                        })
                        .start()
                }
            } else {
                // LOSE, Start game over
                t2.sequence()
                    .then(()=>{
                        roundLabel.setText("game over")
                        roundLabel.visible = true
                    })
                    .wait(2)
                    .then(()=>restartGame())
                    .start()
            }
        }
    }

    function render(time) {
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        moveTerrain(time/1000)
        updateMonsters(time/1000)
        updateCapture(time/1000)
        updateTime(time)
        t2.update()
        renderer.render( scene, camera );
    }

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }
    initScene()
    renderer.setAnimationLoop(render)
</script>
</body>
</html>
