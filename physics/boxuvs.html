<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="../boilerplate/node_modules/three/build/three.min.js"></script>
    <!-- needed for loading GLTF files -->
    <script src="../boilerplate/node_modules/three/examples/js/loaders/GLTFLoader.js"></script>

    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <script src="../boilerplate/vrstats.js" type="module"></script>

    <!-- mouse/touch/vr-controller support -->
    <!--<script src="./pointer.js" type="module"></script>-->

    <style type="text/css">
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

</head>
<body>

<canvas id="debug-canvas" width="128" height="128" style="position:absolute;"></canvas>


<script type="module">
    import {POINTER_CLICK, POINTER_ENTER, POINTER_EXIT, Pointer} from '../boilerplate/pointer.js'
    import VRStats from "../boilerplate/vrstats.js"

    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)

    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;


    function generateTexture() {
        const canvas = document.getElementById('debug-canvas')
        const c = canvas.getContext('2d')
        c.fillStyle = 'white'
        c.fillRect(0,0,canvas.width, canvas.height)

        //lower left for the sides
        c.save()
        c.translate(0,canvas.height/2)
        c.fillStyle = 'red'
        c.fillRect(canvas.width/8*1.5, 0, canvas.width/8, canvas.height/2)
        c.restore()

        //upper left for the bottom and top
        c.save()
        c.translate(0,0)
        c.fillStyle = 'red'
        c.fillRect(canvas.width/8*1.5, 0, canvas.width/8, canvas.height/2)
        c.fillStyle = 'red'
        c.fillRect(0,canvas.height/8*1.5, canvas.width/2, canvas.height/8)
        c.restore()

        c.fillStyle = 'black'
        // c.fillRect(0,canvas.height/2,canvas.width,1)
        // c.fillRect(canvas.width/2,0,1,canvas.height)
    }


    function generateOrnament(data) {
        /*
        the cube has 12 faces. really it has 6 faces, each a square.
        but those squares are each made of two triangles, giving us 12 total triangle
        faces.


         */

        const geo = new THREE.BoxGeometry(1,1,1)
        /*
        geo.faces.forEach((f,i) => {
            console.log("face",i,f)
        })
        */

        /*
        face vertex uvs is an array of arrays. you can have multiple sets of UVs
        but the default geometries only have one, so we always look up index 0

        a face uv is an array of three xy pairs. they represent where each vertex in
        the face (of which there are 3) will be pulled from the text.

        by default all of these values in the cube will be either 0 or 1 because the full square
        texture is mapped each square side of the cube.

        scale down the uvs to use less of the texture. now we are using 0.6 or roughly half
        of the texture.
         */
        /*
        geo.faceVertexUvs[0].forEach((f,i)=>{
            console.log("faceuv",i,f)
            f.forEach(uv=>{
                uv.x *= 0.6
                uv.y *= 0.6
            })
        })
        */

        /*
        now lets modify just the top of the cube
        faces 4 and 5 are the top
        faces 6 and 7 are the bottom
        the rest are the sides
         */
        geo.faceVertexUvs[0].forEach((f,i)=>{
            if(i === 4 || i===5 || i===6 || i===7 ) {
                f.forEach(uv=>{
                    uv.x *= 0.5 //scale down
                    uv.y *= 0.5 //scale down
                    uv.y += 0.5 //move from lower left quadrant to upper left quadrant
                })
            } else {
                //rest of the sides. scale it in
                f.forEach(uv=>{
                    uv.x *= 0.5 // scale down
                    uv.y *= 0.5 // scale down
                })
            }
        })


        const tex = new THREE.CanvasTexture(document.getElementById('debug-canvas'))
        // tex.wrapS = THREE.RepeatWrapping
        // tex.wrapT = THREE.RepeatWrapping
        // tex.repeat.set(16,6)
        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
            // wireframe:true,
            color:'white',
            metalness:0.0,
            roughness:1.0,
            // vertexColors: THREE.VertexColors,
            //required for flat shading
            map:tex,
            // flatShading:true,
        }))
        return mesh
    }


    let cube
    //called on setup. Customize this
    function initContent(scene,camera,renderer) {
        //set the background color of the scene
        scene.background = new THREE.Color( 0xcccccc );

        //a standard light
        const light = new THREE.DirectionalLight( 0xffffff, 1.0 );
        light.position.set( -1, 3, 1 ).normalize();
        scene.add( light );

        const ambient = new THREE.AmbientLight(0xffffff,0.5)
        scene.add(ambient)


        const tex = generateTexture()
        cube = generateOrnament(tex)
        cube.position.z = -5
        //move cube up to camera height (~1.5m)
        cube.position.y = 0.75
        scene.add(cube)


        // enable stats visible inside VR
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)

    }

    //called on every frame. customize this
    function render(time) {
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        //rotate the cube on every tick
        if(cube) cube.rotation.y += 0.02
        if(cube) cube.rotation.x += 0.01
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
