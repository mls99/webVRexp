<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
    <script>
        (function(f, a, t, h, o, m){
            a[h]=a[h]||function(){
                (a[h].q=a[h].q||[]).push(arguments)
            };
            o=f.createElement('script'),
                m=f.getElementsByTagName('script')[0];
            o.async=1; o.src=t; o.id='fathom-script';
            m.parentNode.insertBefore(o,m)
        })(document, window, '//stats.josh.earth/tracker.js', 'fathom');
        fathom('set', 'siteId', 'GISNV');
        fathom('trackPageview');
    </script>
    <!-- / Fathom -->
    <meta charset="UTF-8">
    <title>WebVR + ThreeJS Application</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- required -->
    <script src="../boilerplate/node_modules/three/build/three.min.js"></script>
    <script src="../boilerplate/node_modules/three/examples/js/controls/TransformControls.js"></script>
    <!-- needed to enter VR -->
    <script src="../boilerplate/webvr.js"></script>

    <!-- stats (fps, polygons, fps) -->
    <script src="../boilerplate/vrstats.js" type="module"></script>

    <script src="./node_modules/cannon/build/cannon.js"></script>

    <style type="text/css">
        html, body {
            margin:0;
            padding:0;
            overflow: hidden;
        }
        #overlay {
            position: fixed;
            font-size: 5vh;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0,0,0,0.5);
            text-align: center;
        }
        #loading-indicator {
            display: block;
        }
        #click-to-play {
            /*display: none;*/
            color: black;
            background-color: white;
            border: 1px solid black;
        }

        /* this button is generated by the VR subsystem, disabled if not available */
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%,0);
        }
    </style>

    <!--
https://opengameart.org/content/cloudy-sky

https://freesound.org/people/JohanDeecke/sounds/368335/

https://freesound.org/people/Reitanna/sounds/323725/

https://incompetech.com/music/royalty-free/index.html?collection=8&page=1

    -->

</head>
<body>


<div id="overlay">
    <h1>Application Name</h1>
    <div id="loading-indicator">
        <label>loading</label>
        <progress max="100" value="0" id="progress"></progress>
    </div>
    <h3 id="click-to-play">click to start</h3>
</div>

<script type="module">
    /*
 - Three big piles of crystals held up by one crystal holding up two blocks
1: bounce off a two angled blocks to hit a crystal
10: Three floating platforms with crystals on them
11: a pyramid held up by one big crystal. destroy it to knock them all over
12: Floating wall. Knock block off to hit crystals behind it.
13: stonehenge around you. must make them fall over domino style
14: normal gee + cube, requires a perfect bounce shot to hit four
15: zero gee + cube. smash four floating crystals. have to hit one w/ a bounce because only three shots

- a tall building made out of multiple blocks, and you must hit a crystal on the very top.
- one super high above you hiding behind a floating wall

     */
    import {POINTER_PRESS,POINTER_RELEASE,Pointer} from '../boilerplate/pointer.js'
    import {t2 as T2} from "./t2.js"
    import VRStats from "../boilerplate/vrstats.js"
    import Button2D from "./button2d.js"
    import Label2D from "./label2d.js"
    import Panel2D from './panel2d.js'
    import Group2D from "./group2d.js"
    import {BlockService,BLOCK_TYPES, ROOM_TYPES} from "./BlockService.js"
    import BlockSelection from "./BlockSelection.js"
    import SimpleText from "./SimpleText.js"
    import FireBallAction from "./FireBallAction.js"
    import AudioService from "./AudioService.js"
    import ToggleGroup from './togglegroup2d.js'
    import ToggleButton2D from './togglebutton2d.js'
    import EventMaker from './EventMaker.js'


    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = (deg) => deg * Math.PI/180
    const rand = (min,max) => Math.random()*(max-min) + min
    function keyForValue(obj,val) {
        const keys = Object.keys(obj)
        for(let i=0; i<keys.length; i++) {
            const key = keys[i]
            if(obj[key] === val) return key
        }
        return null
    }


    // global constants and variables for your app go here
    let camera, scene, renderer, pointer, stats;

    const game = {
        blockService:null,
        audioService:null,
        texture_loader: new THREE.TextureLoader(),
        click_sphere:null,
        sound: {
            musicBuffer:null,
            clickSound:null,
            crashSound:null,
            thunkSound:null,
            bg_music:null,
        },
        ui: {
            play_game_button:null,
            crystalCountText:null,
        },
        actions: {
            fire_ball:null
        }
    }

    function parseOptions(opts) {
        let loc = document.location
        if (loc.search) {
            const parts = loc.search.substring(1).split('&')
            parts.forEach((part)=>{
                const keyval = part.split('=')
                opts[keyval[0]] = keyval[1]
            })
        }
        return opts;
    }

    const editor = {
        BASE_URL: "https://vr.josh.earth/360/doc/",
        docid: "tumble_level1",
        control:null
    }

    const opts = parseOptions({docid:'tumble_level1'})
    console.log(opts)
    editor.docid = opts.docid

    console.log("Loading the doc",editor.docid)


    const selection = new BlockSelection()
    function blockClicked(e) {
        selection.clear()
        selection.add(e.target.userData.block)
        editor.control.attach(e.target.userData.block.obj)
        game.ui.blockCount.set('text',`blocks: ${game.blockService.getAllBlocks().length}`)
    }


    let ignore_collisions = false
    let intervalId
    function togglePlayGame() {
        if(game.blockService.isPlaying()) {
            game.click_sphere.visible = false
            game.ui.play_game_button.set('text','play')
            game.blockService.stopPlaying()
            clearInterval(intervalId)
            // if(game.sound.bg_music) game.sound.bg_music.stop()
            scene.remove(game.ui.crystalCountText)
            game.actions.fire_ball.setEnabled(false)
            game.blockService.group.add(editor.designFloor)
        } else {
            game.blockService.group.remove(editor.designFloor)
            game.actions.fire_ball.setEnabled(true)
            // game.sound.bg_music = game.audioService.play("bg")
            // game.sound.bg_music.loop = true
            game.click_sphere.visible = true
            game.ui.play_game_button.set('text','stop')
            game.blockService.startPlaying()
            intervalId = setInterval(()=>{
                const count = game.blockService.getAllBlocks()
                    .filter(b => b.physicsType === BLOCK_TYPES.CRYSTAL)
                    .filter(b => b.obj.visible)
                    .length
                game.ui.crystalCountText.setText(`crystals ${count}`)
            },1*1000)


            game.ui.crystalCountText = new SimpleText(2,1);
            game.ui.crystalCountText.setText("playing")
            game.ui.crystalCountText.position.set(0,3,-2)
            scene.add(game.ui.crystalCountText)
        }
    }

    function addBlock() {
        const block = game.blockService.makeBlock()
        block.positionSet(0,1.0,0)
        on(block.getObject3D(), 'click', blockClicked)
        selection.clear()
        selection.add(block)
        editor.control.attach(block.getObject3D())
    }

    function deleteBlock() {
        selection.getBlocks().forEach((b)=> game.blockService.remove(b))
        editor.control.detach()
        selection.clear()
    }

    function cloneBlock() {
        const newBlocks = selection.getBlocks().map(b => {
            const bb = game.blockService.cloneBlock(b)
            const v3 = b.getObject3D().position.clone().add(new THREE.Vector3(1.5,0,0))
            bb.setPosition(v3)
            on(bb.getObject3D(), 'click', blockClicked)
            return bb
        })
        selection.clear()
        newBlocks.forEach(b => selection.add(b))
        if(newBlocks.length > 0) editor.control.attach(newBlocks[0].getObject3D())

    }

    function setRoomType(type) {
        game.blockService.setRoomType(type)
        dataChanger.fire('changed')
    }

    function initAudio() {
        game.audioService = new AudioService()
        game.audioService.load("click","./sounds/plink.wav")
        game.audioService.load("crash","./sounds/crash1.wav")
        game.audioService.load("thunk","./sounds/thunk.wav")
        game.audioService.load("bg","./music/Visager_-_09_-_Bug_Band_Loop.mp3")
    }


    const texture_loader = new THREE.TextureLoader()

    function destroyCrystal(target) {
        //play glass break sound
        game.audioService.play('crash')
        //remove the block from the scene and simulation
        //must do in a timeout because we are currently in a collide callback
        setTimeout(()=>game.blockService.removeFromSimulation(target),0)
        //add explosion effects
        const v = new THREE.Vector3()
        target.userData.block.obj.localToWorld(v)
    }

    function handleCollision(e) {
        if(game.blockService.ignore_collisions) return

        //ignore tiny collisions
        if(Math.abs(e.contact.getImpactVelocityAlongNormal() < 1.0)) return

        //when ball hits moving block,
        if(e.body.jtype === BLOCK_TYPES.BALL) {
            if (e.target.jtype === BLOCK_TYPES.BLOCK) {
                //hit a block, just make the thunk sound
                game.audioService.play('click')
            }
        }


        //if crystal hits anything and the impact was strong enought
        if(e.body.jtype === BLOCK_TYPES.CRYSTAL || e.target.jtype === BLOCK_TYPES.CRYSTAL) {
            if(Math.abs(e.contact.getImpactVelocityAlongNormal() >= 1.0)) {
                return destroyCrystal(e.target)
            }
        }
        // console.log(`collision: body ${e.body.jtype} target ${e.target.jtype}`)
    }

    function initBlocks(scene) {
        const block2 = game.blockService.makeBlock()
        block2.positionSet(-2,1,0)
        on(block2.getObject3D(),'click',blockClicked)
        const block1 = game.blockService.makeBlock()
        block1.positionSet(0,1,0)
        on(block1.getObject3D(),'click',blockClicked)
        const block3 = game.blockService.makeBlock()
        block3.positionSet(2,1,0)
        on(block3.getObject3D(),'click',blockClicked)
        selection.add(block1)
    }

    function saveStructure() {
        const blockData = game.blockService.generateJSON()
        const doc = {
            id:editor.docid,
            type:'tumble-v1',
            data:{
                blocks:blockData,
                ballMass:game.blockService.ballMass,
                ballRadius:game.blockService.ballRadius,
                wallFriction:game.blockService.wallFriction,
                wallRestitution:game.blockService.wallRestitution,
                hasGravity:game.blockService.hasGravity,
                gravity: {x:0,y:-9.8,z:0},
                roomType:game.blockService.roomType,
            },
        }
        console.log('saving document', JSON.stringify(doc,null,'  '))
        fetch(`${editor.BASE_URL}${editor.docid}`,{
            method:'POST',
            mode:'cors',
            headers: {
                'Content-Type':'application/json'
            },
            body:JSON.stringify(doc)
        })
            .then(resp => resp.json())
            .then(resp => {
                console.log("real response is",resp)
            })
            .catch(e => {
                console.log(e)
            })

    }

    const dataChanger = new EventMaker()

    function loadStructure() {
        fetch(`${editor.BASE_URL}${editor.docid}?cachebust=${Math.random()}`)
            .then(res => res.json())
            .then(res => {
                const blocks = game.blockService.loadFromJSON(res)
                blocks.forEach(b => {
                    on(b.getObject3D(), 'click', blockClicked)
                })
                dataChanger.fire('changed',{})
            })
    }

    function initPanel(scene) {
        function makeGridLayout(cols) {
            return (panel) => {
                panel.comps.forEach((c,i)=>{
                    const col = i%4
                    const row = Math.floor(i/4)
                    c.x = cols[col]
                    c.y=row*25
                })
            }
        }
        const rowLayout = (panel)=>{
            let x = 0
            panel.comps.forEach((c)=>{
                c.x=x
                c.y=0
                x += c.w+panel.padding
            })
        }
        const colLayout = (panel) => {
            let y = 0
            panel.comps.forEach((c)=>{
                c.x=0
                c.y=y
                y += c.h+panel.padding
            })
        }


        const panel = new Panel2D(scene,camera)
        scene.add(panel)

        const subPanels = []
        function switchTo(panel) {
            subPanels.forEach(p =>  p.set('visible',(p===panel)))
        }


        const posPanel = new Group2D().set('x',5).set('y',35).set('w',245).set('h',200).set('visible',true)
            .set('layout',makeGridLayout([0,50,70,100]))
            .childSet('fsize',15)
        subPanels.push(posPanel)
        panel.add(posPanel)

        const sizPanel = new Group2D().set('x',5).set('y',35).set('w',245).set('h',200).set('layout',makeGridLayout([0,50,70,100]))
            .childSet('fsize',15)
            .set('visible',false)
        subPanels.push(sizPanel)
        panel.add(sizPanel)

        const rotPanel = new Group2D().set('x',5).set('y',35).set('w',245).set('h',200).set('layout',makeGridLayout([0,50,70,100]))
            .childSet('fsize',15)
            .set('visible',false)
        panel.add(rotPanel)
        subPanels.push(rotPanel)

        const tabPanel = new Group2D().set('x',0).set('y',0).set('w',250).set('h',32).set('layout',rowLayout).set('padding',0).set('border',0)
        tabPanel.add(new Button2D().set('text','pos').on('click',()=> switchTo(posPanel)))
        tabPanel.add(new Button2D().set('text','siz').on('click',()=> switchTo(sizPanel)))
        tabPanel.add(new Button2D().set('text','rot').on('click',()=> switchTo(rotPanel)))
        panel.add(tabPanel)


        const typePanel = new Group2D()
            .set('x',5).set('y',35)
            .set('w',245).set('h',200)
            .set('visible',false)
            .set('layout',colLayout)
        subPanels.push(typePanel)
        panel.add(typePanel)

        tabPanel.add(new Button2D().set('text','type').on('click',()=> switchTo(typePanel)))


        const types = {
            'block':BLOCK_TYPES.BLOCK,
            'wall':BLOCK_TYPES.WALL,
            'crystal':BLOCK_TYPES.CRYSTAL
        }
        const typeSelector = new ToggleGroup(types).set('w',200).set('h',30).set('value','wall')
            .childSet('fsize',15)
                .on('selected',(group)=> selection.setPropertyValue('physicstype',types[group.get('value')]))
        on(selection,'changed',()=>{
            if(selection.isEmpty()) return
            const type = selection.getProperty('physicstype')
            const key = keyForValue(types,type)
            typeSelector.set('value',key)
        })
        typePanel.add(typeSelector)








        const settingsPanel = new Group2D()
            .set('x',5).set('y',35)
            .set('w',245).set('h',200)
            .set('visible',false)
            .set('layout',makeGridLayout([0,85,105,130]))
            .childSet('fsize',15)
        subPanels.push(settingsPanel)
        panel.add(settingsPanel)

        tabPanel.add(new Button2D().set('text','settings').on('click',()=>{ switchTo(settingsPanel) }))

        function makeValueSetter(name,y, getter, setter, step) {
            const value = new Label2D().set('text',getter().toFixed(2))
            const dec = () => setter(getter()-step)
            const inc = () => setter(getter()+step)
            on(dataChanger,'changed',()=>{
                value.set('text',getter().toFixed(2))
                panel.redraw()
            })
            return [
                new Label2D().set('text',name),
                new Button2D().set('text','-').on('click',dec),
                new Button2D().set('text','+').on('click',inc),
                value,
            ]
        }
        settingsPanel.addAll(makeValueSetter('ball radius', 0,
            ()=> game.blockService.ballRadius,
            (v)=> {
                game.blockService.ballRadius = v
                dataChanger.fire('changed')
            },
            0.1 ))
        settingsPanel.addAll(makeValueSetter('ball mass',   35,
            ()=> game.blockService.ballMass,
            (v)=> {
                game.blockService.ballMass = v
                dataChanger.fire('changed')
            },
            2.0))
        settingsPanel.addAll(makeValueSetter('friction',    70,
            ()=> game.blockService.wallFriction,
            (v)=> {
                game.blockService.wallFriction = v
                game.blockService.rebuildWallMaterial()
                dataChanger.fire('changed')
            },
            0.1
            ))
        settingsPanel.addAll(makeValueSetter('restitution', 105,
            ()=> game.blockService.wallRestitution,
            (v)=> {
                game.blockService.wallRestitution = v
                game.blockService.rebuildWallMaterial()
                dataChanger.fire('changed')
            },
            0.1
            ))


        const roomTypePanel = new Group2D().set('w',235).set('h',30).set('layout',rowLayout).childSet('fsize',15).set('border',0).set('padding',0)
        settingsPanel.add(roomTypePanel)
        roomTypePanel.add(new Label2D().set('text','room type'))
        const setFloorButton = new ToggleButton2D().set('text','floor').on('click',()=>setRoomType(ROOM_TYPES.FLOOR))
        const setCubeButton  = new ToggleButton2D().set('text','cube').on('click',()=>setRoomType(ROOM_TYPES.CUBE))
        roomTypePanel.add(setFloorButton)
        roomTypePanel.add(setCubeButton)
        on(dataChanger,'changed',()=>  {
            setFloorButton.set('selected',game.blockService.roomType === ROOM_TYPES.FLOOR)
            setCubeButton.set('selected',game.blockService.roomType === ROOM_TYPES.CUBE)
        })


        settingsPanel.add(new Label2D().set('text',''))
        settingsPanel.add(new Label2D().set('text',''))
        settingsPanel.add(new Label2D().set('text',''))

        const enableGravity = new ToggleButton2D().set('text','gravity').on('selected',(t)=> game.blockService.hasGravity = t.get('selected'))
        settingsPanel.add(enableGravity)
        on(dataChanger,'changed',()=>  enableGravity.set('selected',game.blockService.hasGravity))

        const g = game.blockService.gravity
        const gravityLabel = new Label2D().set('text',`${g.x},${g.y},${g.z}`)
        settingsPanel.add(gravityLabel)



        function makePropControls(name,y) {
            const label = new Label2D().set('text',name.toUpperCase())
            const value = new Label2D().set('text','0')
            const inc   = new Button2D().set('text','-').on('click',()=> selection.decrementProperty(name))
            const dec   = new Button2D().set('text','+').on('click',()=> selection.incrementProperty(name))
            on(selection,'changed',()=>{
                value.set('text',''+selection.getProperty(name).toFixed(2))
                panel.redraw()
            })
            return [label,inc,dec,value]
        }

        ['x','y','z'].forEach((name,i) => posPanel.addAll(makePropControls(name)));
        ["w","h","d"].forEach((name, i)=> sizPanel.addAll(makePropControls(name)));
        ["rotx","roty","rotz"].forEach((name, i)=> rotPanel.addAll(makePropControls(name)));

        const actionGroup = new Group2D().set('x',5).set('y',250).set('w',80).set('h',150).set('layout',colLayout).childSet('fsize',15)
        panel.add(actionGroup)

        actionGroup.add(new Button2D().set('text','select all')
            .on('click',()=>{
                selection.clear()
                selection.addAll(game.blockService.getAllBlocks())
            })
        )
        actionGroup.add(new Button2D().set('text','add').on('click',addBlock))
        actionGroup.add(new Button2D().set('text','delete').on('click',deleteBlock))
        actionGroup.add(new Button2D().set('text','clone').on('click',cloneBlock))
        actionGroup.add(new Button2D().set('text','save').on('click',saveStructure))
        game.ui.play_game_button = new Button2D().set('text','play').on('click',togglePlayGame)
        actionGroup.add(game.ui.play_game_button)

        const viewGroup = new Group2D().set('x',90).set('y',250).set('w',55).set('h',150).set('layout',colLayout).childSet('fsize',15)
        panel.add(viewGroup)
        viewGroup.add(new Button2D().set('text','CCW').on('click',()=>game.blockService.rotateCCW()))
        viewGroup.add(new Button2D().set('text','CW').on('click',()=>game.blockService.rotateCW()))
        viewGroup.add(new Button2D().set('text','reset').on('click',()=>game.blockService.rotateReset()))

        panel.add(new Label2D().set('text',`editing ${editor.docid}`).set('fsize',15).set('x',100).set('y',480))

        game.ui.blockCount = new Label2D().set('text',`blocks:`).set('fsize',15).set('x',100).set('y',460);
        panel.add(game.ui.blockCount)

        panel.redraw()
        panel.position.set(-1.5,1.5,-2)
        panel.lookAt(camera.position)
    }

    function initTransformControls(scene) {
        editor.control = new THREE.TransformControls(camera,renderer.domElement)
        editor.control.setTranslationSnap(0.1)
        editor.control.setSpace('local')
        editor.control.setSize(3)
        // on(editor.control,'change',(e)=>{
        //     console.log("trnasform control chnaged",e.target)
        // })
        on(editor.control,'dragging-changed',(e)=>{
            const blk = selection.getBlocks()[0]
            blk.setPosition(blk.obj.position.clone())
        })
        scene.add(editor.control)
    }

    function initContent(scene,camera,renderer) {
        game.blockService = new BlockService(scene)
        on(game.blockService,'collision',handleCollision)
        initAudio()
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap

        //set the background color of the scene
        scene.background = new THREE.Color( 0xcccccc );

        //a standard light
        const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
        light.castShadow = true
        light.shadow.mapSize.width = 512
        light.shadow.mapSize.height = 512
        light.shadow.camera.right = 10
        light.shadow.camera.top = 10
        light.position.set( 0, 1, 1 ).normalize();
        scene.add( light );

        scene.add(new THREE.AmbientLight(0xffffff,0.5))





        // enable stats visible inside VR
        stats = new VRStats(renderer)
        camera.add(stats)
        scene.add(camera)

        //class which handles mouse and VR controller
        pointer = new Pointer(scene,renderer,camera, {

            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:true,

            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:false,
            enableLaser: true,
            laserLength:8,
        })



        initBlocks(scene)

        initPanel(scene)

        initFloor(scene)

        initBall(scene)

        initTransformControls(scene)

        $("#overlay").style.visibility = 'hidden'
        if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')

        loadStructure()
    }

    function initFloor(scene) {

        //background image
        scene.add(new THREE.Mesh(
            new THREE.SphereGeometry(20),
            new THREE.MeshBasicMaterial({
                color:'white',
                map:texture_loader.load('./textures/sky2.jpg'),
                side: THREE.BackSide
            })
        ))

        //floor of the game area
        const designFloor = new THREE.Mesh(
            new THREE.CircleGeometry(3),
            new THREE.MeshLambertMaterial({color:'magenta'})
        )
        designFloor.rotation.x = toRad(-90)
        designFloor.position.y = 0.01
        designFloor.receiveShadow = true
        editor.designFloor = designFloor
        game.blockService.group.add(designFloor)
    }



    function initBall(scene) {
        game.click_sphere = new THREE.Mesh(
            new THREE.SphereGeometry(4),
            new THREE.MeshLambertMaterial({color:'green', side:THREE.BackSide, transparent:true, opacity:0.3})
        )
        game.click_sphere.visible = false
        game.click_sphere.material.visible = false
        game.click_sphere.userData.clickable = true
        game.click_sphere.position.set(0,0,0)
        scene.add(game.click_sphere)

        game.actions.fire_ball = new FireBallAction(scene, pointer.controller1, game)
        on(game.click_sphere,POINTER_PRESS,game.actions.fire_ball.startPressSphere)
        on(game.click_sphere,POINTER_RELEASE,game.actions.fire_ball.endPressSphere)
    }

    //called on every frame. customize this
    function render(time) {
        T2.update(time)
        //update the pointer and stats, if configured
        if(pointer) pointer.tick(time)
        if(stats) stats.update(time)
        game.blockService.update(time)
        if(game.actions.fire_ball) game.actions.fire_ball.updatePressSphere(time)
        renderer.render( scene, camera );
    }


    // you shouldn't need to modify much below here

    function initScene() {
        //create DIV for the canvas
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaOutput = true
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );
        document.body.appendChild( WEBVR.createButton( renderer ) );

        initContent(scene,camera,renderer)

        window.addEventListener( 'resize', ()=>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false );

        THREE.DefaultLoadingManager.onStart = (url, loaded, total) => {
            console.log(`loading ${url}.  loaded ${loaded} of ${total}`)
        }
        THREE.DefaultLoadingManager.onLoad = () => {
            console.log(`loading complete`)
            console.log("really setting it up now")
            $('#loading-indicator').style.display = 'none'
            $('#click-to-play').style.display = 'block'
            const overlay = $('#overlay')
            $("#click-to-play").addEventListener('click',()=>{
                overlay.style.visibility = 'hidden'
                if($('#enter-vr'))  $('#enter-vr').removeAttribute('disabled')
            })
        }
        THREE.DefaultLoadingManager.onProgress = (url, loaded, total) => {
            console.log(`prog ${url}.  loaded ${loaded} of ${total}`)
            $("#progress").setAttribute('value',100*(loaded/total))
        }
        THREE.DefaultLoadingManager.onError = (url) => {
            console.log(`error loading ${url}`)
        }


    }



    // initPage()
    initScene()
    renderer.setAnimationLoop(render)

</script>
</body>
</html>
